CalculateKuromi.java

```java

/**
 * 盲盒抽取kuromi算法
 * 回溯算法 + 剪枝 解决全排列问题
 */
public class KuromiSolution {
    private int len;
    private List<List<Integer>> res;
    private int[] nums;
    // 每个位置上不可能出现的值
    private Map<Integer, List<Integer>> impossibleMap;
    // 每个位置上确定的值
    private int[] determineResult;
    // 最终计算的奖品
    private int price;

    private int[][] count;

    public List<List<Integer>> permute(int[] nums, Map<Integer, List<Integer>> impossibleMap, int[] determineResult, int price) {
        this.nums = nums;
        this.impossibleMap = impossibleMap;
        this.determineResult = determineResult;
        this.len = nums.length;
        this.price = price;
        this.count = new int[len][1];
        res = new ArrayList<>();
        boolean[] used = new boolean[len];
        List<Integer> path = new ArrayList<>();
        backtrack(0, path, used);
        return res;
    }

    private void backtrack(int depth, List<Integer> path, boolean[] used) {
        if (depth == len && path.size() == len) {
            this.count[path.indexOf(price)][0] += 1;
            res.add(new ArrayList<>(path));
            return;
        }
        // 针对每一列，尝试是否可放置
        for (int i = 0; i < len; i++) {
            if (!used[i]) {
                int target = nums[i];
                if ((determineResult[depth] == 0 || determineResult[depth] == target) &&
                        !impossibleMap.get(depth).contains(target)) {
                    path.add(target);
                    used[i] = true;
                    backtrack(depth + 1, path, used);
                    used[i] = false;
                    path.remove(depth);
                }
            }
        }
    }

    public int[][] getCount() {
        return count;
    }
}


```

Resouce.java

```java
package com.arvin.demo.kuromi;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Resource {
    private final String[] prize;
    private final int[] nums;
    private final int target;
    private final int size;
    private final String targetName;
    private final Map<Integer, List<Integer>> impossibleMap = new HashMap<>();
    private final int[] determineResult;

    public Resource(String fileName) throws IOException {
        Path path = Paths.get(fileName);
        BufferedReader bufferedReader = Files.newBufferedReader(path);
        String line;
        List<String> lineList = new ArrayList<>();
        while ((line = bufferedReader.readLine()) != null) {
            lineList.add(line);
        }
        bufferedReader.close();

        // 处理获取到到数据
        // 奖品
        String prizeString = lineList.get(0);
        this.prize = prizeString.split(" ");
        this.nums = new int[prize.length];
        for (int i = 0; i < nums.length; i++) {
            nums[i] = i + 1;
        }

        // 要抽取的目标
        String targetString = lineList.get(2);
        String[] targetArr = targetString.split(" ");
        this.size = Integer.parseInt(targetArr[0]);
        this.target = Integer.parseInt(targetArr[1]);
        this.targetName = prize[target - 1];
        this.determineResult = new int[size];

        for (int i = 3; i < lineList.size(); i++) {
            String lines = lineList.get(i);
            String[] impossibleArr = lines.split(" ");
            int index = Integer.parseInt(impossibleArr[0]) - 1;
            List<Integer> impossibleTarget = new ArrayList<>();
            determineResult[index] = Integer.parseInt(impossibleArr[1]);
            for (int j = 2; j < impossibleArr.length; j++) {
                impossibleTarget.add(Integer.parseInt(impossibleArr[j]));
            }
            impossibleMap.put(index, impossibleTarget);
        }
    }

    public String[] getPrize() {
        return prize;
    }

    public int getTarget() {
        return target;
    }

    public int getSize() {
        return size;
    }

    public String getTargetName() {
        return targetName;
    }

    public Map<Integer, List<Integer>> getImpossibleMap() {
        return impossibleMap;
    }

    public int[] getDetermineResult() {
        return determineResult;
    }

    public int[] getNums() {
        return nums;
    }
}

```

